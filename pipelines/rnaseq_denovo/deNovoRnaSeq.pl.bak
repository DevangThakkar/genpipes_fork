#!/usr/bin/perl

=head1 NAME

I<deNovoRnaSeq>

=head1 SYNOPSIS

deNovoRnaSeq.pl

=head1 DESCRIPTION

B<deNovoRnaSeq> Is the main de novo RNAseq pipeline.

=head1 AUTHOR

B<Joel Fillon> - I<joel.fillon@mcgill.ca>

=head1 DEPENDENCY

B<Pod::Usage> Usage and help output.

B<Data::Dumper> Used to debbug

B<Config::Simple> Used to parse config file

B<File::Basename> path parsing

B<Cwd> path parsing

=cut

# Strict Pragmas
#---------------------
use strict;
use warnings;
#---------------------

BEGIN{
  #Makesure we can find the GetConfig::LoadModules module relative to this script install
  use File::Basename;
  use Cwd 'abs_path';
  my (undef, $mod_path, undef) = fileparse(abs_path(__FILE__));
  unshift @INC, $mod_path . "lib";
}


# Dependencies
#--------------------
use Getopt::Std;
use Cwd qw/ abs_path /;

use LoadConfig;
use Picard;
use SampleSheet;
use SAMtools;
use SequenceDictionaryParser;
use SubmitToCluster;
use TophatBowtie;

#--------------------


# SUB
#--------------------

my @steps;
push(@steps, {'name' => 'normalization', 'stepLoop' => 'group', 'output' => 'metrics'});

# Initialize global dependencies
my %globalDep;
for my $stepName (@steps) {
  $globalDep{$stepName->{'name'}} = {};
}


# Global scope variables
my $designFilePath;
my $configFile;
my $workDir;
my $readSetSheet;


&main();

sub printUsage {
  print "\nUsage: perl " . $0 . " \n";
  print "\t-c  config file\n";
  print "\t-s  start step, inclusive\n";
  print "\t-e  end step, inclusive\n";
  print "\t-n  nanuq sample sheet\n";
  print "\t-d  design file\n";
  print "\t-w  work directory\n";
  print "\n";
  print "Steps:\n";
  for (my $idx = 0; $idx < @steps; $idx++) {
    print "" . ($idx + 1) . '- ' . $steps[$idx]->{'name'} . "\n";
  }
  print "\n";
}

sub main {

  # Check user options
  my %opts;
  getopts('c:s:e:n:d:w:', \%opts);

  if (!defined($opts{'c'}) || !defined($opts{'s'}) || !defined($opts{'e'}) || !defined($opts{'n'}) || !defined($opts{'d'}) || !defined($opts{'w'})) {
    printUsage();
    exit(1);
  }

  # Initialize global pipeline variables
  my %jobIdVarPrefix;
  my %cfg = LoadConfig->readConfigFile($opts{'c'});
  my $rHoAoH_sampleInfo = SampleSheet::parseSampleSheetAsHash($opts{'n'});
#  my $rAoH_seqDictionary = SequenceDictionaryParser::readDictFile(\%cfg);
  $designFilePath = abs_path($opts{'d'});
  # Get design groups
  my $rHoAoA_designGroup = Cufflinks::getDesign(\%cfg, $designFilePath);
  $workDir = abs_path($opts{'w'});
  $configFile = abs_path($opts{'c'});
  $readSetSheet = abs_path($opts{'n'});


  # Generate sample jobIdprefix
  my $cpt = 1;

  for my $sampleName (keys %{$rHoAoH_sampleInfo}) {
    my $cpt2 = 1;
    $jobIdVarPrefix{$sampleName} = $cpt;
    my $rAoH_sampleLanes = $rHoAoH_sampleInfo->{$sampleName};
    for my $rH_laneInfo (@$rAoH_sampleLanes) {
      $jobIdVarPrefix{$sampleName . '.' . $rH_laneInfo->{'runId'} . "_" . $rH_laneInfo->{'lane'}} = $cpt . '_' . $cpt2;
      $cpt2++;
    }
    $cpt++;
  }
  #generate design jobIdprefix
  for my $designName (keys %{$rHoAoA_designGroup}) {
    $jobIdVarPrefix{$designName} = $cpt;
    $cpt++;
  }

  SubmitToCluster::initPipeline($workDir);

  for(my $current = $opts{'s'} - 1; $current <= ($opts{'e'} - 1); $current++) {
    my $fname = $steps[$current]->{'name'};
    my $loopType = $steps[$current]->{'stepLoop'};
    my $subref = \&$fname;
    if ($loopType eq 'sample') {
      for my $sampleName (keys %{$rHoAoH_sampleInfo}) {
      my $rAoH_sampleLanes = $rHoAoH_sampleInfo->{$sampleName};
      # Tests for the first step in the list. Used for dependencies.
      my $jobIdVar = &$subref($current != ($opts{'s'} - 1), \%cfg, $sampleName, $rAoH_sampleLanes, $rAoH_seqDictionary, \%jobIdVarPrefix);
      if (defined($jobIdVar)) {
        $globalDep{$fname}->{$sampleName} = $jobIdVar;
      }
      }
    }
    else {
      # Tests for the first step in the list. Used for dependencies.
      my $jobIdVar = &$subref($current != ($opts{'s'} - 1), \%cfg, $rHoAoH_sampleInfo, $rHoAoA_designGroup, $rAoH_seqDictionary, \%jobIdVarPrefix);
      if (defined($jobIdVar)) {
        $globalDep{$fname}->{$fname} = $jobIdVar;
      }
    }
  }
}

sub normalization {
  my $depends = shift;
  my $rH_cfg = shift;
  my $rHoAoH_sampleInfo = shift;
  my $rHoAoA_designGroup = shift;
  my $rAoH_seqDictionary = shift;
  my $rH_jobIdPrefixe = shift;

  my $options = LoadConfig::getParam($rH_cfg, 'normalization', 'options');
  my $trimmingDependency = undef;
  if($depends > 0) {
    $trimmingDependency = join(LoadConfig::getParam($rH_cfg, 'default', 'clusterDependencySep'), values(%{$globalDep{'trimming'}}));
  }
  print "mkdir -p metrics/\n";
  my $folder = 'reads';
  my $pattern = 'trim.stats.csv';
  my $ouputFile = 'metrics/trimming.stats';
  my $rO_job = Metrics::mergeTrimmomaticStats($rH_cfg, $libraryType, $pattern, $folder, $ouputFile);
  if(!$rO_job->isUp2Date()) {
    SubmitToCluster::printSubmitCmd($rH_cfg, "normalization", undef, 'NORMALIZATION', $trimmingDependency, undef, $rO_job);
  }
  return $rO_job->getCommandJobId(0);
}
