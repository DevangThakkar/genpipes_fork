#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use File::Temp;
use Env qw/TMPDIR/;
use Statistics::R;
use Data::Dumper;

$SIG{INT} = sub{exit};  #sigint();

my $usage=<<'ENDHERE';
NAME:
qscorePlots.pl

PURPOSE:
Takes the qscores sheet generated by the fastx_quality_stats 
tool and generates boxplots using R.

INPUT:
--single
    --infile_1 <qscore_tab_file> : Qscore sheet generated by 
                                   FastX compute quality statistics tool.
	
--paired
    --infile_1 <qscore_tab_file> : Qscore sheet generated by FastX compute quality statistics tool.
    --infile_2 <qscore_tab_file> : Qscore sheet generated by FastX compute quality statistics tool.

--separate
    --infile <infile>            : Qscore sheet generated by FastX compute quality statistics tool. 
                                   if submitting multiple files in input, just put multiple 
                                   --input args.
    --name <string>              : Name for graph header. There has to be the same number of 
                                   --infile and --name args.

--rows <int>                     : Number of rows for graph display
--col <int>                      : Number of columns for graph display
--display <int>                  : 1 or 2

either --single --paired or --separate

OUTPUT:
--pdf <pdf_outfile>              : one pdf file contaning Qscore graphs

NOTES:

BUGS/LIMITATIONS:

AUTHOR/SUPPORT:
     Julien Tremblay - jtremblay@lbl.gov
ENDHERE

## OPTIONS
my ($help, $infile_1, $infile_2, $row, $col, $pdf, $single, $paired, $separate, @infile, @name, $display);
my $verbose = 0;

GetOptions(
    'infile_1=s'	=> \$infile_1,
	'infile_2=s' 	=> \$infile_2,
	'infile=s'		=> \@infile,
	'name=s' 		=> \@name,
    'pdf=s' 		=> \$pdf,
	'rows=s' 		=> \$row,
	'col=s' 		=> \$col,
    'verbose' 		=> \$verbose,
	'single' 		=> \$single,
	'paired' 		=> \$paired,
	'separate' 		=> \$separate,
	'display=s' 	=> \$display,
    'help' 			=> \$help
);
if ($help) { print $usage; exit; }

#VALIDATE
die "Can't enter --separate --single and --paired; just one\n" if($separate and $single and $paired);
die "Can't enter --separate --paired; just one\n" if($separate and $paired);
die "Can't enter --separate --single; just one\n" if($separate and $single);
die "Can't enter both --single and --paired; just one\n" if($single and $paired);
die "--pdf please specify an output pdf file\n" unless $pdf;
die "--display required\n" unless $display;
die "Please specify either one of these args: --single, --paired or --separate" unless($single or $paired or $separate);
if($single){
	die "--infile_1 required\n" unless $infile_1;
	die "--infile_2 not required\n" if $infile_2;
}elsif($paired){
	die "--infile_1 required\n" unless $infile_1;
	die "--infile_2 required\n" unless $infile_2;
}elsif($separate){
	#At least one file.
	die "--infile at least one --infile arg required\n" unless @infile > 0;
	die "--name at least one --infile arg required\n" unless @name > 0;
	die "number of --infile and --name don't match" if(@name != @infile);
}

## MAIN
no warnings 'numeric';
no warnings 'redefine';

my $cex;
my $format;
if($display == 1){
	$row = 2;
	$col = 2;
	$cex = 0.7;
	$format = "c(1,10,20,30,40)";
}elsif($display == 2){
	$row = 4;
	$col = 2;
	$cex = 0.65;
	$format = "c(1,20,40)";
}

## TEMP DIR
my $tmpdir = File::Temp->newdir(
	"tmpDirItaggerQscoreGraphsXXXXXXX",
	DIR => $TMPDIR."/",
	CLEANUP => 0 #Let itagger.pl manage the removal of temp files.
);

my $R = Statistics::R->new();
$R->startR;

my $hist_string= "";
my @array;
my $counter = 0;
my $id;

#LOOP THROUGH FILE 1, AND STORE STRINGS IN ARRAY OR HASH
my %hash_1=();
if($single or $paired){
	$id = "";
	open(IN_1, $infile_1) or die "Can't open file ".$infile_1."\n";
	while(<IN_1>){
		chomp($_);
		if(substr($_,0,2) eq ">>"){ #Start
			if($_ =~ m/>>(.*)/){
				$id = $1;
			}else{
				die "Failed to get id of qscores...\n";
			}
			$hash_1{$id} = "";
		}elsif($_ eq "//"){#End
			$id = "";
		}elsif($_ =~ m/column/){
			next;
		}else{#Body
			$hash_1{$id} .= $_."\n";
		}	
	}
	close(IN_1);
}

#LOOP THROUGH FILE 2, AND STORE STRINGS IN ARRAY OR HASH
$id = "";
my %hash_2=();
if($paired){
	open(IN_2, $infile_2) or die "Can't open file ".$infile_2."\n";
	while(<IN_2>){
		chomp($_);
		if(substr($_,0,2) eq ">>"){ #Start
			if($_ =~ m/>>(.*)/){
				$id = $1;	
			}else{
				die "Failed to get id of qscores...\n";
			}
			$hash_2{$id} = "";
		}elsif($_ eq "//"){#End
			$id = "";
		}elsif($_ =~ m/column/){
			next;
		}else{#Body
			$hash_2{$id} .= $_."\n";
		}	
	}
	close(IN_2);
}

#LOOP THROUGH HASHES AND CONSTRUCT R STRINGS.
my $number_of_files;
if($paired){
	$number_of_files = 2;
}elsif($single){
	$number_of_files = 1;
}elsif($separate){
	$number_of_files = 0;
}

if($paired or $single){
	for my $key (sort {$a<=>$b} keys %hash_1 ){
		my $value_1 = $hash_1{$key} if($single or $paired);
		my $value_2 = $hash_2{$key} if($paired);
		
		my $i=0;
		my $curr_file = "";
		my $curr_name;
	
		while($i < $number_of_files){
			if($i == 0){
			   	$curr_name = $key."_reads_1";
				$curr_file = $tmpdir."/".$curr_name;
				open(TEMP, ">".$tmpdir."/".$curr_name);
				print TEMP $value_1;
				close(TEMP);
			}
			if($i == 1){
				$curr_name = $key."_reads_2";
				$curr_file = $tmpdir."/".$curr_name;
				open(TEMP, ">".$tmpdir."/".$curr_name);
				print TEMP $value_2;
				close(TEMP);
			}
			print $curr_name."\n" if($verbose);
			print $curr_file."\n" if($verbose);
		
			if(!-e $curr_file || !-s $curr_file){
		        my $curr_string = 'plot(0,0)
		                        box(lwd=1)
		                        mtext("No data for '.$curr_name.'", cex=0.65)
		                        ';
		        push(@array,$curr_string);
				$i++;
		        $counter++;
		        #print $curr_file." do not exist\n";
	        	next;
	    	}	

			$R->run("data_".$counter." <- read.table('".$curr_file."', sep='\t', header=F, skip=0)");
			$R->run("mySum_".$counter." <- NULL");
			$R->run("mySum_".$counter."\$stats <- t(data_".$counter."[,11])");
			$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,7]))");
			$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,8]))");
			$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,9]))");
			$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,12]))");
	
			my $curr_string = '
				my_mgp <- par()$mgp
				#my_mgp[1] <- 4
				my_mgp[2] <- 0.5
				#my_mgp[3] <- 3
				par(mgp=my_mgp)
		
				my_mar <- par()$mar
				my_mar[2] <- 4
				par(mar=my_mar)
		
				boxplot(
					mySum_'.$counter.'$stats,
					notch = FALSE,
					width = NULL,
					varwidth = FALSE,
				    outline = FALSE,
				    notch.frac = 0.5,
				    boxcol= FALSE,
				    pars = NULL,
				    horizontal = FALSE,
				    add = FALSE,
				    at = NULL,
				    show.names = NULL,
				    boxfill= rgb(1,0.58,0.09,1),
				    outl= FALSE,
				    main="",
				    axes=FALSE,
					ylim=c(0,40),
				)
				box(lwd='.$cex.')
				axis(side=1, lwd = 0.5, las=1, cex.axis='.$cex.')
				axis(side=2, lwd = 0.5, las=2, , at='.$format.',labels=formatC('.$format.', big.mark=",", format = "d"), cex.axis='.$cex.')
				mtext("Position", side=1, line=1, cex='.$cex.')
				mtext("Quality score", side=2, line=2, cex='.$cex.')
				mtext("'.$curr_name.'", 3, cex='.$cex.')
				grid(nx = 0, ny = 20, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
				abline(h=20, lwd=0.4)';
			$i++;
			$counter++;
			push(@array, $curr_string);
		}
	}
}

if($separate){	
	foreach(@infile){
		my $curr_name = shift(@name);
		my $curr_file = $_;
		if(!-e $curr_file || !-s $curr_file){
	        my $curr_string = 'plot(0,0)
	                       box(lwd=1)
	                       mtext("No data for '.$curr_name.'", cex=0.65)
	                       ';
	        push(@array,$curr_string);
			#shift(@name);
	        $counter++;
	        #print $curr_file." do not exist\n";
	       	next;
	   	}	

		$R->run("data_".$counter." <- read.table('".$curr_file."', sep='\t', header=T, skip=1)");
		$R->run("mySum_".$counter." <- NULL");
		$R->run("mySum_".$counter."\$stats <- t(data_".$counter."[,11])");
		$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,7]))");
		$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,8]))");
		$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,9]))");
		$R->run("mySum_".$counter."\$stats <- (rbind(mySum_".$counter."\$stats, data_".$counter."[,12]))");
		#$R->run("write.table(mySum_".$counter."\$stats, '"."/house/homedirs/t/tremblay/temp/"."test_".$counter.".tab', sep='\t')");
	
		my $curr_string = '
			my_mgp <- par()$mgp
			#my_mgp[1] <- 4
			my_mgp[2] <- 0.5
			#my_mgp[3] <- 3
			par(mgp=my_mgp)
		
			my_mar <- par()$mar
			my_mar[2] <- 4
			par(mar=my_mar)
		
			boxplot(
				mySum_'.$counter.'$stats,
				notch = FALSE,
				width = NULL,
				varwidth = FALSE,
			    outline = FALSE,
			    notch.frac = 0.5,
			    boxcol= FALSE,
			    pars = NULL,
			    horizontal = FALSE,
			    add = FALSE,
			    at = NULL,
			    show.names = NULL,
			    boxfill= rgb(1,0.58,0.09,1),
			    outl= FALSE,
			    main="",
			    axes=FALSE,
				ylim=c(0,40),
			)
			box(lwd='.$cex.')
			axis(side=1, lwd = 0.5, las=1, cex.axis='.$cex.')
			axis(side=2, lwd = 0.5, las=2, , at='.$format.',labels=formatC('.$format.', big.mark=",", format = "d"), cex.axis='.$cex.')
			mtext("Position", side=1, line=1, cex='.$cex.')
			mtext("Quality score", side=2, line=2, cex='.$cex.')
			mtext("'.$curr_name.'", 3, cex='.$cex.')
			grid(nx = 0, ny = 20, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
			abline(h=20, lwd=0.4)
		';
		$counter++;
		push(@array, $curr_string);
	}
}

$R->run('pdf("'.$pdf.'" , width=7, height=7)');
$R->run('par(mfrow=c('.$row.','.$col.'))'); 
foreach my $cmd (@array){
	$R->run($cmd);
	#print $cmd."\n";
}
$R->run('dev.off()');

1;
exit;

## REMOVE TEMP FILES
sub END{
	local $?;
	#print STDOUT "Cleaning up temporary files...\n";
	system("rm ".$tmpdir." -rf");
}
